# Лабораторная работа №2

Выполнил студент гр. БСТ2201 Ованов Роман

## Описание
Реализовать следующие структуры данных:

● Стек (stack):
Операции для стека: инициализация, проверка на пустоту, добавление нового элемента в начало, извлечение элемента из начала;

● Дек (двусторонняя очередь, deque):
Операции для дека: инициализация, проверка на пустоту, добавление нового элемента в начало, добавление нового элемента в конец, извлечение элемента из начала, извлечение элемента из конца.

Разработать программу обработки данных, содержащихся в заранее подготовленном txt-файле, в соответствии с заданиями, применив указанную в задании структуру данных. Результат работы
программы вывести на экран и сохранить в отдельном txt-файле.

## Код, реализующий дек и стек (deq_stack.py):
```python
class Node:
    def __init__(self, el):
        self.next = None
        self.prev = None
        self.el = el


class Stack:
    count: int
    last: Node | None
    
    def __init__(self):
        self.last = None
        self.count = 0
    
    def push(self, el):
        node = Node(el)
        self.count += 1
        if self.last:
            self.last.next = node
            node.prev = self.last
        self.last = node
    
    def pop(self):
        if self.last:
            el = self.last.el
            self.last = self.last.prev
            self.count -= 1
            return el
        else:
            raise IndexError
    
    def get_last(self):
        return self.last.el
    
    def __len__(self):
        return self.count

class Dequeue:
    count: int
    first: Node | None
    last: Node | None

def __init__(self):
    self.count = 0

    self.first = None
    self.last = None

def push_first(self, el):
    node = Node(el)
    if self.first:
        node.next = self.first
        self.first.prev = node
    if not self.last:
        self.last = node
    self.first = node
    self.count += 1

def push_last(self, el):
    node = Node(el)
    if self.last:
        self.last.next = node
        node.prev = self.last
    if not self.first:
        self.first = node
    self.last = node
    self.count += 1

def pop_last(self):
    if self.last:
        el = self.last.el
        self.last = self.last.prev
        self.count -= 1
        return el
    else:
        raise IndexError

def pop_first(self):
    if self.first:
        el = self.first.el
        self.first = self.first.next
        self.count -= 1
        return el
    else:
        raise IndexError

def __len__(self):
    return self.count
```

## Задание 1 (1/lab2.1.py)
**Отсортировать строки файла, содержащие названия книг, в алфавитном порядке с использованием двух деков.**

*Из файла unsorted_books.txt программа читает названия книг, далее сортирует их в алфавитном порядке с помощью дека (class Dequeue), а затем выводит результат на экран, а также записывает в файл sorted_books.txt*

## Задание 2 (2/lab2.2.py)
**Дек содержит последовательность символов для шифровки сообщений. Дан текстовый файл, содержащий зашифрованное сообщение. Пользуясь деком, расшифровать текст. Известно, что при
шифровке каждый символ сообщения заменялся следующим за ним в деке по часовой стрелке через один.**

*Из файла crypt_word.txt программа читает зашифрованное слово, далее, с помощью дека (class Dequeue) расшифровывает слово по принципу "шифра Цезаря", а затем выводит результат на экран, а также записывает в файл decrypted_word.txt*

## Задание 3 (3/lab2.3.py)
**Даны три стержня и n дисков различного размера. Диски можно надевать на стержни, образуя из них башни. Перенести n дисков со стержня А на стержень С, сохранив их первоначальный
порядок.**
При переносе дисков необходимо соблюдать следующие правила:
  1. на каждом шаге со стержня на стержень переносить только один диск;
  2. диск нельзя помещать на диск меньшего размера;
  3. для промежуточного хранения можно использовать стержень В.

Реализовать алгоритм, используя три стека вместо стержней А, В, С. Информация о дисках хранится в исходном файле.

*Эта программа, по сути, реализует принцип "Ханойской башни"*

## Задание 4 (4/lab2.4.py)
**Дан текстовый файл с программой на алгоритмическом языке. За один просмотр файла проверить баланс круглых скобок в тексте, используя стек.**

*Из файла alg.txt программа читает код, далее с помощью стека (class Stack) проверяет баланс скобок, а затем выводит результат на экран, а также записывает в файл brackets_balance_result.txt*

## Задание 5 (5/lab2.5.py)
**Дан текстовый файл с программой на алгоритмическом языке. За один просмотр файла проверить баланс квадратных скобок в тексте, используя дек.**

*Из файла alg2.txt программа читает код, далее с помощью дека (class Dequeue) проверяет баланс скобок, а затем выводит результат на экран, а также записывает в файл brackets_balance_result.txt*

## Задание 6 (6/lab2.6.py)
**Дан файл из символов. Используя стек, за один просмотр файла напечатать сначала все цифры, затем все буквы, и, наконец, все остальные символы, сохраняя исходный порядок в каждой группе символов.**

*Из файла symbol.txt программа читает микс символов, букв и цифр, далее с помощью дека (class Stack) делает так, чтобы сначала выводились цифры, затем буквы, а потом символы (сохраняя исходный порядок), а затем выводит результат на экран, а также записывает в файл results.txt*

## Задание 7 (7/lab2.7.py)
**Дан файл из целых чисел. Используя дек, за один просмотр файла напечатать сначала все отрицательные числа, затем все положительные числа, сохраняя исходный порядок в каждой группе.**

*Из файла sifri.txt программа читает цифры, далее, с помощью дека (class Dequeue) делает так, чтобы сначала выводились отрицательные числа, а потом положительные (сохраняя исходный порядок), затем выводит результат на экран, а также записывает в файл result.txt*

## Задание 8 (8/lab2.8.py)
**Дан текстовый файл. Используя стек, сформировать новый текстовый файл, содержащий строки исходного файла, записанные в обратном порядке: первая строка становится последней, вторая – предпоследней и т.д.**

*Из файла bukvi.txt программа читает текст, который разделён на строки, далее, с помощью стека (class Stack) меняет местами строки, а затем записывает в файл reverce.txt*

